import React, { useLayoutEffect } from 'react';
import styled from 'styled-components';
import { Head, SubHead, Code, Block } from '../components/shared';
import Important from '../components/Important';
import CodeBlock from '../components/Code';

import treePng from '../images/tree.png';

const BinTreeImg = styled.img`
  width: 200px;
`;

const Stuff = () => {
  useLayoutEffect(() => {
    window.scrollTo(0, 0);
  }, []);

  return (
    <>
      <Head>Алгоритмы и структуры данных</Head>
      <p>
        Алгоритм это последовательность действий (например, линейный и бинарный поиск, сортировка пузырьком, выбором 
        или вставками), а структура данных это то, над чем вы осуществляете эти действия (например, массив, пары 
        «ключ-значение»). Структура данных - это способ хранения и обработки данных.
      </p>
      <Block>
        <SubHead>Временная сложность алгоритма O(n)</SubHead>
        <p>
          <b>O-нотация</b> - обозначение, описывающее зависимость количества операций от входных данных<br />
          <b>O(1)</b> - одна опреация (например определить чётное или нечётное)<br />
          <b>O(log n)</b> - всегда меньше чем половина n - например поиск в телефонном справочнике - открыли в середине,
          потом в середине половины итд (разделяй и властвуй)<br />
          <b>O(n)</b> - линейная зависимость (для массива - равна количеству элементов массива)<br />
          <b>O(n * log n)</b> - болльшинство алгоритмов сортировки<br />
          <b>O(n<sup>2</sup>)</b> - любой цикл в цикле<br />
          <b>O(2<sup>n</sup>) и O(n!)</b> - только с малым количеством данных - очень сложные! Если будет много данных 
          - повиснет браузер<br />
        </p>
        <Important>
          Например у массива push и length имеют сложность O(1) - а shift и unshift - O(n) - потому что чтобы
          добавить в начало или удалить из начала элемент - нужно все элементы сдвинуть и присвоить им новые индексы!
        </Important>
      </Block>
      <Block>
        <SubHead>Массив (Array)</SubHead>
        <p>
          Массив напоминает пронумерованные ячейки (где номера это индексы), расположенные по порядку. С помощью индекса
          можно обратиться к любой ячейке чтобы посмотреть ее содержимое. Хорошая индексация О(1) - по индексу можно
          обратиться к элемнту, но поиск, вставка и удаление - O(n)
        </p>
      </Block>
      <Block>
        <SubHead>Hash Table (Object, Set, Map)</SubHead>
        <p>
          Индексация в JS - это O(1) так как обращаемся по ключу! А также поиск, вставка и удаление - O(1)!!!
        </p>
        <p>
          Вот пример разницы в производительности - одна и та же задача решается за 8 секунд или за 112 миллисекунд!!!
          Мы всего лишь преобразовали один из массивов в хэш мапу и сложность поиска (indexOf) изменилась с O(n) на O(1)
        </p>
<CodeBlock>{`// Здесь имеем цикл в цикле
let resultArr = arr0.filter(item => {
  return arr1.indexOf(item) !== -1; // indexOf под капотом тоже просто цикл
})

// этот код для массива из 10000 элементов выполняется 8 секунд

// const start = perfomance.now();
// const end = perfomance.now() - start;
`}
</CodeBlock>

<CodeBlock>{`// Теперь попробуем конвертировать один из массивов в hash map
let hashMap = {}

arr1.forEach(item => {
  hashMap[item] = null;
})

let resultArr = arr0.filter(item => {
  return typeOf hashMap[item] !== undefined;
})

// !!! Этот код выполнится за 112 миллисекунд !!!
`}
</CodeBlock>
        <p>
          Еще пример - Множественные проверки
        </p>
<CodeBlock>{`// Плохой вариант:
if (user.group === 'admin') {
  alert('Hello Admin!');
} else if (user.group === 'editor') {
  alert('Hello Editor!');
} else {
  alert('Hello User!');
}

// Лучше так:
let greets = {
  admin: 'Admin',
  editor: 'Editor!',
  user: 'User!',
}

alert(\`Hello \${greets[user.group]}\`);
`}
</CodeBlock>
      </Block>
      <Block>
        <SubHead>Стэк</SubHead>
        <p>
          Структура в которой элементы добавляются только в конец и удаляются из конца! (last in - first out)
          Индексация <b>O(n)</b>, Поиск <b>O(n)</b>, Вставка <b>O(1)</b>, Удаление <b>O(1)</b>. В JS реализуется с 
          помощью массива.
        </p>
        <p>
          <b>Где используется:</b><br />
          1. Парсеры ({'<div><p><a></a></p></div>'})<br />
          2. Транспиляторы ({'{({[({})]({})})}'})<br />
          3. Стэк вызовов функций Javascript<br />
          4. Истории изменений<br />
        </p>
      </Block>
      <Block>
        <SubHead>Очередь</SubHead>
        <p>
          Структура в которой элементы добавляются в конец а удаляются из конца начала (first in - first out).
          Индексация <b>O(n)</b>, Поиск <b>O(n)</b>, Вставка <b>O(1)</b>, Удаление <b>O(1)</b>.
        </p>
        <p>
          <b>Где используется:</b><br />
          1. Очереди<br />
          2. Очереди событий Javascript<br />
        </p>
      </Block>
      <Block>
        <SubHead>Связанные списки</SubHead>
        <p>
          Не пользуется популярностью. Эти списки хранят последовательность! Каждый элемент содержит свое значение и 
          ссылку на следующий элемент.
          Если удалить элемент - сохранится последовательность. Используются для построения других структур данных.
          Например очередь реализуется на связанных списках.
          Индексация <b>O(n)</b>, Поиск <b>O(n)</b>, Вставка <b>O(1)</b>, Удаление <b>O(1)</b>.
        </p>
        <p>
          <b>Где используется:</b><br />
          1. Очереди<br />
          2. Очереди событий Javascript<br />
        </p>
<CodeBlock>{`let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null // ! последний элемент
      }
    }
  }
};

// Вывод списка через цикл
function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }
}

// Вывод списка через рекурсию
function printList(list) {
  alert(list.value); // выводим текущий элемент

  if (list.next) {
    printList(list.next); // делаем то же самое для остальной части списка
  }
}

printList(list);
`}
</CodeBlock>
      </Block>
      <Block>
        <SubHead>Бинарное дерево</SubHead>
        <p>
          Классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива 
          на половины.
        </p>
        <p>
          Сначала сортируем массив .sort() - у этой операции сложность O(n * log(n))
          Затем ищем как в телефонном справочнике: смотрим элемент посередине. Если искомый элемент больше - тогда
          отбрасываем первую половину и ищем только во второй - также смотрим средний элемент этой половины итд.
          тоесть сложность уже O(log(n))
        </p>
        <p>
          Индексация <b>O(log(n))</b>, Поиск <b>O(log(n))</b>, Вставка <b>O(log(n))</b>, Удаление <b>O(log(n))</b> - 
          все логарифмическая сложность, то есть на любое действие понадобится в два раза меньше операций чем туда 
          зашло данных!
        </p>
        <p>
          Например есть массив: [5, 8, 13, 6, 4, 3, 9]<br />
          Как можно найти элемент в этом массиве?<br />
          <Code className="mr">indexOf/includes</Code> - O(n)<br />
          Можно превратить в hash table - O(n+1) - перебрать и обратиться по индексу<br />
          Отсортировать массив! - алгоритмы в отсортированном массиве работают быстрее!
          И искать - тогда будет O(n * log(n) + log(n)) => O(n * log(n))<br />
          И наконец бинарное дерево - O(log(n))
        </p>
        <BinTreeImg src={treePng} alt="" />
<CodeBlock>{`function binarySearch(arr, item)){
  while (arr.length !== 1) {
    let pivotIndex = Math.floor(arr.length/2);
    if (arr[pivotIndex] < item) {
      arr = arr.slice(pivotIndex, arr.length); // именно slice! Он возвращает новый массив (нет мутаций)
    } else if (arr[pivotIndex] > item) {
      arr = arr.slice(0, pivotIndex);
    } else {
      return true;
    }

    return item === arr[0];
  }
}
`}
</CodeBlock>
      </Block>
    </>
  );
}

export default Stuff;