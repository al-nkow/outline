import React, { Component } from 'react';
import { tomorrow } from 'react-syntax-highlighter/dist/styles/prism';

import Important from '../components/Important';
import { Head, SubHead, StyledSyntaxHighlighter } from '../components/shared';
import CookieImg from '../images/cookie.png';
import styled from 'styled-components';

const Image = styled.img`
  display: block;
  max-width: 400px;
  margin: 5px 0;
`;

const code1 = `var socket = new WebSocket("ws://javascript.ru/ws");
`;

class ApiPage extends Component {
  render () {
    return (
      <div>
        <Head>Application Programming Interface (API)</Head>
        <p>
          Позволяет компонентам ПО взаимодействовать между собой
        </p>
        <Important>
          Браузер предоставляет библиотеки и объекты, которые позволяют Вам
          контролировать web страницу
        </Important>
        <p>
          - Добавлять, удалять и изменять элементы страницы<br/>
          - Move, resize, transform elements<br/>
          - Управлять формами и инпутами<br/>
          - Валидировать формы перед отправкой на сервер<br/>
          - Делать запросы на сервер (ajax)<br/>
          - Хранение данных (cookies, local storage, session storage)<br/>
          - HTML5: audio, video, canvas, location<br/>
          - Javascript shims (позволяет разным фичам работать в разных
          браузерах если где-то не поддерживается)
        </p>
        <Important>
          Browser API's это НЕ Javascript! это только библиотеки и не являются языком
        </Important>
        <p>API обычно используют JSON как главный язык</p>

        <SubHead>Http Request Function</SubHead>
        <p>
          Старая версия: XMLHttpRequest (HTTP(s): GET, POST, PUT, DELETE)<br/>
          <b>В новой версии уже есть:</b><br/>
          бинарные файлы и данные<br/>
          поддержка html форм (объект FormData)<br/>
          кросс-доменные запросы (CORS)<br/>
          события о процессе загрузки<br/>
        </p>

        <SubHead>Fetch</SubHead>
        <p>
          Метод fetch – это XMLHttpRequest нового поколения. Он предоставляет улучшенный
          интерфейс для осуществления запросов к серверу: как по части возможностей и
          контроля над происходящим, так и по синтаксису, так как построен на промисах.
        </p>

        <SubHead>Websocket</SubHead>
        <p>
          Это протокол, предназначенный для обмена сообщениями между браузером и
          веб-сервером в режиме реального времени (поверх TCP соединения).
          Он позволяет пересылать любые данные, на любой домен, безопасно и почти без
          лишнего сетевого трафика. Экономит трафик, работает над http. Пересылать
          можно любые данные, в том числе и файлы!
        </p>
        <StyledSyntaxHighlighter language='javascript' style={tomorrow}>
          {code1}
        </StyledSyntaxHighlighter>
        <p>
          У объекта socket есть четыре коллбэка: один при получении данных и три – при
          изменениях в состоянии соединения: socket.onopen, socket.onclose, socket.onmessage,
          socket.onerror.
        </p>
        <p>
          Соединение WebSocket можно открывать как WS:// или как WSS://. Протокол WSS
          представляет собой WebSocket над HTTPS.
        </p>

        <SubHead>Server Side Events (SSE)</SubHead>
        <p>
          Современный стандарт <b>Server-Sent Events</b> позволяет браузеру создавать специальный
          объект EventSource, который сам обеспечивает соединение с сервером, делает
          пересоединение в случае обрыва и генерирует события при поступлении данных.
          Он, по дизайну, может меньше, чем WebSocket’ы.
          С другой стороны, Server Side Events проще в реализации, работают по обычному
          протоколу HTTP и сразу поддерживают ряд возможностей, которые для WebSocket
          ещё надо реализовать.
          Поэтому в тех случаях, когда нужна преимущественно односторонняя передача
          данных от сервера к браузеру, они могут быть удачным выбором.
        </p>

        <SubHead>WEB RTC</SubHead>
        <p>
          Это API для двунаправленной передачи текста и бинарного медиа напрямую между клиентами.
          - онлайн игры<br/>
          - обмен данными, которые важны клиенту, но не важны серверу<br/>
          - сделать лучший скайп
        </p>

        <SubHead>HTTP протокол</SubHead>
        <p>
          Протокол для передачи гипертекстовых документов (в 1ю очередь для html документов).
          Состоит из запроса и ответа, после этого соединение следует закрыть.
        </p>
        <p>
          Методы:<br/>
          <b>GET</b> - получение документа<br/>
          <b>HEAD</b> - получение только заголовков<br/>
          <b>POST</b> - отправка данных на сервер<br/>
          <b>PUT</b> - отправка документа на сервер<br/>
          <b>DELETE</b> - удаление документа<br/>
          <b>CONNECT, TRACE, OPTIONS</b> - используется редко<br/>
          <b>COPY, MOVE, MKCOL</b> - расширение WebDAV
        </p>

        <SubHead>HTTP коды ответа</SubHead>
        <p>
          <b>1хх</b> - информационные<br/>
          <b>2хх</b> - успешное выполнение<br/>
          <b>3хх</b> - перенаправление (запрос может быть неудачный, но документ можно найти
          по другому url, либо существуют другие версии документа)<br/>
          <b>4хх</b> - ошибка на стороне клиента<br/>
          <b>5хх</b> - ошибка на стороне сервера<br/>
        </p>
        <p>
          <b>200</b> - Ок<br/>
          <b>204</b> - No connect<br/>
          <b>301</b> - файл переместили в другое место, перенаправляет<br/>
          <b>302</b> - то же, что 301, только не кешируется (временно переместили)<br/>
          <b>304</b> - документ не изменился, используем кэш<br/>
          <b>400</b> - Bad request - неправильный синтаксис запроса<br/>
          <b>401</b> - Unauthorized - требуется авторизация<br/>
          <b>403</b> - Forbidden - нет доступа (обычно в паре с 401) или логин/пароль не подошел<br/>
          <b>404</b> - документ не найден (обычно url неправильный)<br/>
          <b>500</b> - ошибка сервера (неожиданная, необработанное исключение например)<br/>
          <b>502</b> - Bad gateway - проксируемый ответ с ошибкой<br/>
          <b>504</b> - проксируемый сервер не отвечает<br/>
        </p>
        <Important>
          Проксировать - значит передать запрос к другому веб серверу
        </Important>

        <SubHead>HTTP заголовки</SubHead>
        <p>
          С помощью них устанавливаются все опции протокола.
        </p>
        <p>
          <b>Content-Type</b> - MIME тип документа<br/>
          <b>Content-Length</b> - длина сообщения<br/>
          <b>Content-Encoding</b> - кодирование, например g-zip сжатие<br/>
          <b>Transfer-Encoding</b> - формат передачи, например chunked<br/>
          <b>Connection</b> - Управление соединением<br/>
          <b>Upgrade</b> - Смена протокола<br/>
        </p>

        <SubHead>Заголовки запросов</SubHead>
        <p>
          <b>Authorization</b> - Чаще всего логин/пароль или токен и.т.д.<br/>
          <b>Cookie</b> - Передача состояния (сессии) на сервер<br/>
          <b>Refer</b> - url предыдущего документа (контекст запроса). Например: грузим картинку, а здесь url страницы
          Можно проанализировать откуда пришел пользователь на сайт, из какого поисковика например.<br/>
          <b>User-agent</b> - описание web клиента, версия браузера<br/>
          <b>if-Modified-Since</b> - условный get запрос (совместно с кодом 304)<br/>
          <b>Accept*</b> - согласование (negotiation) содержимого. Согласование формата документа, какие
          документы готов принять браузер.<br/>
        </p>

        <SubHead>Заголовки HTTP ответов</SubHead>
        <p>
          <b>Location</b> - новый url при редиректе (301, 302)<br/>
          <b>Set-Cookie</b> - установка состояния (сессии) в браузере<br/>
          <Image src={CookieImg} alt=""/>
          <b>Last Modified</b> - дата последнего изменения (в связке с 304 Conditional GET)<br/>
          <b>Date</b> - дата (текущее время) на сервере (для согласования кэшей)<br/>
          <b>Server</b> - описание web сервера, название и версия (это типа user-agent только для сервера)
        </p>

        <SubHead>HTTP 1.1 управление соединением</SubHead>
        <p>
          Клиент 1.0 закроет соединение, как только получит ответ от сервера. Сервер 1.0 закроет, как только отправил ответ.
        </p>
        <p>
          Протокол 1.1 предполагает по умолчанию открытое соединение - удержание TCP соединения, если не было заголовка
          <b>Connection: close</b>
        </p>
        <p>
          Для скриптов, картинок, стилей и так далее загрузка идет по тому же соединению, что существенно ускоряет
          загрузку страницы в целом
        </p>
        <Important>Но эти соединения не живут долго - у них очень короткий таймаут - около 10с</Important>
        <p>
          Новые протоколы SPDY, HTTP 2.0 еще более ускоряют загрузку страницы
        </p>

        <SubHead>Что происходит в браузере после ввода адреса сайта?</SubHead>
        <p>
          Основа: клиент-сервер! HTTP - протокол передачи гипертекста<br/>
          1. Поиск ближайшего DNS сервера чтобы преобразовать URI в его числовое представление<br/>
          2. Установка соединения с сервером по полученному IP-адресу<br/>
          3. Отправка данных (запрос на отправку сайта). Это сообщение передается по протоколу TCP/IP<br/>
          4. Ответ от сервера. Если 200 - всё ок! Или может прийти редирект. Затем сервер начинает отправку сайта в браузер
          в виде небольших порций (пакетов)<br/>
          5. Браузер собирает пакеты в сайт. Если надо - браузер декодирует ответ - gzip
        </p>
        <Important>
          Если определяет версию файла, зашифрованного в браузере и файл не менялся со времени последнего запроса,
          то ответ будет <b>304 not modified</b> - клиенту не посылается никакой контент, а браузер достает html из кэша
        </Important>
        <p>
          1. Html-парсер разбирает документ в DOM дерево<br/>
          2. После этого браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и.т.д.)<br/>
          3. Рендеринг путем разбора узлов DOM дерева и применения CSS
        </p>
        <Important>
          Браузер загружает страницу сверху вниз. Стили (в head), HTML разметка (теги), скрипты (перед закрывающим body)
        </Important>

        <SubHead>REST</SubHead>
        <p>
          Это стиль архитектуры программного обеспечения для построения распределенных
          масштабируемых веб сервисов. REST API - это набор функций к которым можно отправлять
          запросы и получать ответы.
        </p>
        <p>
          Различная смысловая нагрузка HTTP запросов: GET, POST, PUT, DELETE, CONNECT,
          HEAD, OPTIONS, PATCH, TRACE, CREATE, READ...
        </p>
        <p>
          Определенные коды ответов: 200 оk, 201 created, 203 not authorized,
          404 not found, 406 not acceptable, 500 server error
        </p>

        <SubHead>JSON pure API</SubHead>
        <p>
          Использует только один метод для передачи данных - POST для HTTP и GET для WEBSOCKET.
          Только один код ответа - 200. Передача и ответ независимы. Любой канал связи http/s,
          websocket, XMPP, telnet, SFTP, SCP, SSH.
        </p>
      </div>
    );
  }
}

export default ApiPage;