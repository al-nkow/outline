import React, { PureComponent } from 'react';
import { Head, SubHead } from '../components/shared';

class SolidPage extends PureComponent {
  componentDidMount() {
    window.scrollTo(0, 0);
  }

  render () {
    return (
      <div>
        <Head>Принципы SOLID</Head>
        <p>Это аббревиатура для пяти принципов объектно-ориентированного дизайна.</p>
        <p>
          1. <b>Single Responsibility</b> принцип единственной ответственности<br/>
          2. <b>Open - closed</b> принцип открытости - закрытости<br/>
          3. <b>Liskov substitution</b> принцип подстановки Барбары Лисков<br/>
          4. <b>Interface segregation</b> принцип разделения интерфейса<br/>
          5. <b>Dependency inversion</b> принципы инверсии зависимостей<br/>
        </p>

        <SubHead>Принцип единственной ответственности</SubHead>
        <p>
          Сущестует лишь одна причина, приводящая к изменению класса. Каждый класс выполняет
          лишь одну задачу. Нужно делать повторно используемые компоненты очень маленькими и
          простыми, с минимумом ответственности.
        </p>

        <SubHead>Принцип открытости - закрытости</SubHead>
        <p>
          Программные сущности должны быть открыты для расширения, но закрыты для модификации.
          Никогда! Не при каких обстоятельствах не модифицируем код компонентов, которые
          часто используются. То есть если нужен какой-то новый функционал - добавь новый метод классу.
          Исходный код не меняется - правятся только баги. Если очень надо - можно просто отнаследоваться от класса
          (extends)
        </p>

        <SubHead>Принцип подстановки Барбары Лисков</SubHead>
        <p>
          Наследующий класс должен дополнять, а не замещать поведение базового класса. Любой
          компонент может быть заменен другим так, чтовсе остальные компоненты не должны заметить
          подмены.
        </p>

        <SubHead>Принцип разделения интерфейса</SubHead>
        <p>
          Много интерфейсов, специально предназначенных для клиентов, лучше, чем один общего
          назначения. Вместо написания обобщенных компонентов на все случаи жизни, пишем
          простые конкретные реализации.
        </p>

        <SubHead>Принцип инверсии зависимостей</SubHead>
        <p>
          Решение о том, какой из компонентов будет использован в каждом случае, должен принимать
          вызывающий код. Зависимость на абстракциях. Нет зависимости на что-то конкретное.
          Модули верхних уровней не должны зависеть от модулей нижних уровней.
        </p>
        <p>
          Например, мы реализуем хранение документов в веб-приложении. На первый взгляд, кажется 
          логичным добавить зависимость от модулей работы с файловой системой непосредственно в класс, 
          отвечающий за высокоуровневую работу с этими документами. Но в перспективе такая зависимость 
          может создать проблемы — например, нам потребуется хранить данные не только на диске, но и в облаке. 
          Если зависимость внедрена от реализации, то мы столкнёмся с необходимостью её переработки. 
          Если же зависимость выведена на уровень абстракции (интерфейса), то нам будет достаточно реализовать 
          функционал работы с облаком, соответствующий ранее созданному интерфейсу работы с файлами.
        </p>
      </div>
    );
  }
}

export default SolidPage;